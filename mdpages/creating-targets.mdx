---
title: Creating Targets
---

# [${meta.title}]

---

The philosophy behind Chalet projects is quite simple: Abstract away only what needs to be abstracted, and unify as much of the build as possible.

\\

## [Target Types]

By far the most important part of a Chalet project is its targets. Targets are defined in sequential order, and describe individual source compilation targets, CMake projects, other Chalet project, or scripts.

* Source Target - A folder, set of folders, or files with compilation options. Two types can be made:
   * [Executable Source Target](/schema/latest/target-source-executable) - Describes an executable file to output
   * [Library Source Target](/schema/latest/target-source-library) - Describes a static or shared library to output
* [Chalet Target](/schema/latest/target-chalet) - A subfolder that contains a separate chalet.json
* [CMake Target](/schema/latest/target-cmake) - A subfolder that contains a CMakeLists.txt
* [Script Target](/schema/latest/target-script) - An individual script to run
* [Process Target](/schema/latest/target-process) - A single process with arguments to run

```json
"targets": {
   "first": {
      "kind": "executable",
      "files": "src/first/**.cpp"
   },
   "second": {
      "kind": "cmakeProject",
      "location": "vendor/second"
   },
   "third": {
      "kind": "chaletProject",
      "location": "vendor/third"
   },
   "fourth": {
      "kind": "process",
      "path": "myexec",
      "arguments": [
         "--foo"
      ]
   },
   "post-build": {
      "kind": "script",
      "file": "scripts/post-build.py"
   }
}
```

With this approach, external dependencies can be pulled in from other sources like git, placed wherever we need them, and built as closely as possible to the rest of the project without necessarily having to write extra scripts. Chalet can orchestrate that work for you, in addition to simply building your own source code. 

\\

## [Abstract Targets]

Abstracts are source targets that do not build by themselves, and instead get extended by source targets. For example, if there are two different source targets that both require the same compilation options, one can write them out twice, but that wouldn't be very programmatic. The solution for this is to create an abstract and extend it in each source target. They can be declared in one of two ways.

Firstly, with a root `abstracts` object:

```json
"abstracts": {
   "*": {},
   "minimal": {}
}
```

Secondly, with a colon separating `abstracts` and the name of the abstract target directly in the property key:

```json
// Possibly more desireable in small projects
"abstracts:*": {},
"abstracts:minimal": {}
```

Which one you decide to use doesn't matter, but it's recommended to pick one style over the other rather than mix them. 

An example of how abstracts could be used is if stricter warnings are desired on one target, while they need to be more relaxed on another:

```json
"abstracts": {
   "strict-warnings": {
      "settings:Cxx": {
         "warnings": "strict"
      }
   },
   "min-warnings": {
      "settings:Cxx": {
         "warnings": "minimal"
      }
   }
},
"targets": {
   "first-target": {
      "extends": "strict-warnings"
   },
   "second-target": {
      "extends": "strict-warnings"
   },
   "third-target": {
      "extends": "min-warnings"
   }
}
```

`*` is a special abstract target that gets implicitly extended in all source targets. Therefore, there's no need to define `"extends": "*"` since it would be equivalent to not defining it.

```json
"abstracts:*": {},
"targets": {
   "my-project": {
      // "extends": "*"
   }
}
```

\\

Another way of writing the strict/minimal example, utilizing `*` would be:

```json
"abstracts:*": {
   "settings:Cxx": {
      "warnings": "strict"
   }
},
"targets": {
   "first-target": {},
   "second-target": {},
   "third-target": {
      "settings:Cxx": {
         "warnings": "minimal"
      }
   }
}
```

`"warnings": "minimal"` would simply override `"warnings": "strict"` in this case.

This pattern is useful in situations where one target needs to be compiled as C, while the rest as C++. Another example is that perhaps one target is code you maintain, while another target is code coming from a library written by somebody else.

> Note: A single source target can extend a single abstract target, but an abstract target can not extend another abstract target.

\\

## [Source Targets]

With abstracts out of the way, we can start thinking about how to structure our source targets. As you would expect with any C++ build system, we can add include directories, macro definitions, compiler warnings, define precompiled headers, and a handful of other goodies to ensure our project remains as compiler-independent and cross-platform as possible. 

```json
"targets": {
   "my-project": {
      "kind": "executable",
      "language": "C++",
      "settings:Cxx": {
         "pch": "src/PCH.hpp",
         "cppStandard": "c++20",
         "warnings": "strict",
         "threads": true,
         "rtti": false,
         "exceptions": true,
         "staticLinking": false,
         "defines": [
            "LIB_FOO"
         ],
         "defines:debug": [
            "_DEBUG"
         ],
         "includeDirs": [
            "${externalDir}/foo/include",
            "${externalDir}/bar/include"
         ],
         "libDirs": [
            "${externalDir}/foo/lib"
         ],
         "links": [
            "foo"
         ],
         "links.windows": [
            "bar"
         ]
      },
      "files": "src/**.cpp",
      "runTarget": true
   }
}
```

Some of these properties will be covered here, while others will be explained are detailed in the schema documentation, [here](http://localhost:3000/schema-dev/main/executable-source-target).

The main required properties for source targets are `language`, `kind`, `settings` and `location` / `files`.

The `language` property is pretty self-explanatory. Accepted values are `C++` and `C`, and on MacOS, `Objective-C` and `Objective-C++`.

> Note: Objective-C++ implies C++, and Objective-C implies C, so files of both types can be combined in the same source target.

When the `kind` property is either `executable` `sharedLibrary` or `staticLibrary`, the target is considered a source target.

\\

## [Target Descriptions]

All target types can take a `description` property that explicitly changes the header to something else. For example, if the list of targets look something like:

```json
"targets": {
   "my-target": {}
}
```

The default output would be:

```
▼  Build: my-target
```

If the description is changed:

```json
"targets": {
   "my-target": {
      "description": "My super cool project!"
   }
}
```

The output would become:

```
▼  My super cool project!
```

> Note: Unicode is supported (given the capabilities of the terminal), so as long as chalet.json itself is Unicode, the description should display correctly.

\\

## [Property Conditions]

Most properties support conditions that describe whether to include or exclude them from the build. These are simply suffixes that describe the build configuration or platform:

* `debug` / `!debug` if the build configuration uses debug symbols (Debug/RelWithDebInfo/Profile) or doesn't use them.
* `(platform)` / `!(platform)` where platform is or isn't `macos` `linux` & `windows`
* For targeting compilers and architectures, see [Advanced: Fine Tuning](/creating-targets?id=advanced-fine-tuning)

Conditions are contextual, so not all properties support all conditions.

If a single property (such as "links") is defined with multiple conditions, each one will be read in the order they're declared.

```json
"links": [
   "foo"
],
"links.debug": [
   "bar"
]
"links.windows": [
   "another"
]
```

In the above example, if one is building the Debug configuration on windows, `foo` is added first, followed by `bar` and then `another`. If Release: `foo` is still added first followed by `another`.

\

**Excluding Targets**

Targets can be excluded with the `condition` property, and work the exact same way as property conditions:

```json
"first-target": {
   "condition": "debug.!windows"
}
"second-target": {
   "condition": "linux"
}
```

\\

## [Adding Source Files]

Source files can either be added individually or via a glob pattern. In both scenarios, source files will be based on their extensions:

* C++: Any extension other than the ones below, but most common are `cpp` `cc` `cxx` `c++` `C`
* C: `c` (case-sensitive)
* Windows Resource: `rc` / `RC`
* Objective-C: `m` / `M`
* Objective-C++: `mm`

C++ header files should not be specified at all, so for instance if you're using `.cpp` and `.h` files, only add 

> Note: Lowercase extensions are recommended

\

To start defining files, simply add a property called `files`. They can be added individually via an array:

```json
"files": [
   "src/main.cpp",
   "src/foo.cpp",
   "src/bar.cpp"
]
```

Or matched via a glob pattern:

```json
"files": [
   "src/**.cpp",
   "tests/*.cpp"
]
```

`*` in this case matches files in a single path, while `**` matches files recursively though any subdirectories. Therefor, these can be combined with the following pattern if you wish to exclude files in a directory, but include any of its subdirectories:

```json
"files": [
   "src/*/**.cpp"
]
```

Using glob patterns, files can also be expressed as a single string:

```json
"files": "src/**.{cpp,rc}"
```


Property conditions are also supported:

```json
"files": [
   "src/Foo/**.cpp"
]
"files.windows": [
   "src/Windows/**.cpp"
]
"files.macos": [
   "src/MacOS/**.cpp"
]
```

The above example would detect any `.cpp` and `.rc` files within the `src` folder. Extensions must be separated by a comma or a `|` character and surrouned by a set of curly brackets.

Files can also be expressed as an object with `include` and `exclude`. Excludes can be expressed as an exact file match, a glob pattern, or a regular string to match against.

```json
"files": {
   "include": "src/**.cpp",
   "exclude.!macos": [
      "src/MacOS"
   ],
   "exclude.!linux": [
      "Linux"
   ]
}
```

> Note: Because files can be declared differently, no assumptions are made about [include directories](/creating-targets?id=include-directories), so if `src/**.cpp` is the pattern used, `src` should be included 

\

\\

## [Compile Settings]

Like with abstracts, compile settings can be expressed in two ways:

```json
"my-project": {
   "settings:Cxx": {}
}
```

or:

```json
"my-project": {
   "settings": {
      "Cxx": {}
   }
}
```

> Note: At the moment, `Cxx` is the only sub-type, but as Chalet matures, more may be added.

\\

## [Language Standard]

The C and C++ language standard are represented as `cStandard` and `cppStandard` respectively. If using GCC and clang, the language standard is given directly to the compiler, while if using MSVC, it's reinterpreted to a supported flag.

Examples:

```json
// /std:c++20 in MSVC (19.29 or higher)
"cppStandard": "c++20"
"cppStandard": "gnu++2b"

// /std:c++17 in MSVC (19.11 or higher)
"cppStandard": "c++17" 

// /std:c17 in MSVC (19.28 or higher)
"cStandard": "gnu17"

// /std:c11 in MSVC (19.28 or higher)
"cStandard": "c11"
```

MSVC will fall back to `/std:latest` if the standard isn't recognized.

> Note: With this approach, One can try out new C++ versions without needing an update of chalet first

\\

## [Include Directories]

These are directories (preferably relative) to be included during compilation, and tell the compiler where header files are located. This is expressed with the `includeDirs` property, where all [Path Substitutions](/creating-targets?id=path-substitution) and glob patterns apply. The simplest example is the following:

```json
"includeDirs": [
   "src"
]
```

This means the `src` folder is a root of included paths, so folders are required in `#include` directives.

```cpp
#include "foo.hpp"         // src/foo.hpp
#include "bar/bar.hpp"     // src/folder/bar.hpp
```

```json
"includeDirs": [
   "${externalDir}/foo/include",
]
```

Typically this means if a library has subdirectories, you have to declare your include directives in code as: 

```cpp
#include <subdir/foo.hpp>  // ${externalDir}/foo/include/subdir/foo.hpp
```

Some might want to do the following:

```cpp
#include <foo.hpp>         // ${externalDir}/foo/include/subdir/foo.hpp
#include "bar.hpp"         // src/folder/bar.hpp
```

Glob patterns are also supported for this reason, so one can include a directory recursively:

```json
"includeDirs": [
   "${externalDir}/foo/include/**",
   "src/**"
]
```

However, the problem with this approach is that simply adding a folder will add another include path to the build command, forcing a recompile of that target, so it would be more desirable to either place all sources in a single folder, or use the previous subfolder approach. This would ultimately come down to personal preference.

> Note: compiler include paths are automatically added.

See also: [Advanced: Fine Tuning](/creating-targets?id=advanced-fine-tuning)

\\

## [Library Search Paths]

These are directories (preferably relative) that are used to search for static or dynamic libraries at link time. If you're looking to link a library called `foo`, you must tell the linker where `foo.lib` or `libfoo.a` exist. This is expressed with the `libDirs` property, where all [Path Substitutions](/creating-targets?id=path-substitution) and glob patterns are supported.

Example:

```json
"libDirs": [
   "${externalBuildDir}/foo/lib"
]
"libDirs.windows": [
   "${env:ProgramFiles}/bar/lib"
]
"libDirs.!windows": [
   "~/libraries/bar/lib"
]
```

> Note: compiler lib paths are automatically added.

See also: [Advanced: Fine Tuning](/creating-targets?id=advanced-fine-tuning)

\\

## [Preprocessor Definitions]

These are preprocessor symbols to pass to the compiler **per target**. These are typically used to define something globally that affects how the target gets compiled for its usage. 

For example, in a debug build, you're probably going to want to define `DEBUG` or `_DEBUG` (this is not done for you).

```json
"abstracts:*": {
   "settings:Cxx": {
      "defines.debug": [
         "_DEBUG"
      ]
   }
}
```

See also: [Advanced: Fine Tuning](/creating-targets?id=advanced-fine-tuning)

\\

## [Warnings]

Deciding which warnings to use is a central part of working with C++. There are two ways to declare them: As a preset, or as a GNU-style list.

\

**Warning Presets**

Presets are inherently opinionated. Their goal is to provide an abstraction that can be interpreted by all compilers. With GCC & clang, they will populate a list of warnings behinds the scenes, try to limit them based on the compiler version, and pass them along. Both compilers tend to support each other in that if a warning is available on one, but not the other, it tends to just be a no-op. When in doubt: test.

```json
"my-target": {
   "settings:Cxx": {
     "warnings": "strict"
   }
}
```

In GCC/Clang, the presets are as follows:

* **none** - No warnings (default). This is the same as not defining `warnings` at all.
* **minimal** - Equivalent to `-Wall`.
* **extra** - Equivalent to **minimal** + `-Wextra`.
* **pedantic** - Equivalent to **extra** + `-Wpedantic`.
* **error** - Equivalent to **pedantic** + `-Werror`. Warnings will be treated as errors.
* **strict** - Equivalent to **error** + `-Wunused` `-Wcast-align` `-Wdouble-promotion` `-Wformat=2` `-Wmissing-declarations` `-Wmissing-include-dirs` `-Wnon-virtual-dtor` `-Wredundant-decls`. Warnings will be treated as errors.
* **strictPedantic** - Equivalent to **strict** + `-Wunreachable-code` `-Wshadow`. Warnings will be treated as errors.
* **veryStrict** - Equivalent to **strictPedantic** + `-Wnoexcept` `-Wundef` `-Wconversion` `-Wcast-qual` `-Wfloat-equal` `-Winline` `-Wold-style-cast` `-Wstrict-null-sentinel` `-Woverloaded-virtual` `-Wsign-conversion` `-Wsign-promo`. Warnings will be treated as errors.

In MSVC, presets are interpreted as the warning level:

* **none** - No warnings (default). This is the same as not defining `warnings` at all.
* **minimal** - Equivalent to `/W1`.
* **extra** - Equivalent to `/W2`.
* **pedantic** - Equivalent to `/W3`.
* **error** - Equivalent to `/W3 /WX`. Warnings will be treated as errors.
* **strict**, **strictPedantic** & **veryStrict**  - Equivalent to `/W4 /WX`. Warnings will be treated as errors.

> Note: If you'd like to use `/Wall`, it must be added manually.

> Note: These may change between some Chalet versions (probably not very often), as they have the potential to be pretty contentious. [Debate](//github.com/chalet-org/chalet-dev/discussions) is welcomed.

\

**Explicit GNU-style List**

Warnings can be defined manually, as a list of their GNU names, minus the `-W` prefix. If the compiler is GCC or clang, the list is passed along directly to the compile commands, without any further validation (although this behavior may get tweaked in the future).

```json
"my-target": {
   "settings:Cxx": {
      "warnings": [
         "all",
         "error",
         "unused",
         "shadow",
         "unreachable-code",
         "format=2"
      ]
   }
}
```

In MSVC, warning flags will be cross-referenced based on how presets are defined above, so if "pedantic" is present in the list, the flag will be `/W3`. If "error" or any of the strict/veryStrict GNU names are present, `/WX` will get added.

See also: [Advanced: Fine Tuning](/creating-targets?id=advanced-fine-tuning)

\\

## [Precompiled Headers]

For the unfamiliar, this is a convention used to speed up the build process by compiling common headers up front. A single precompiled header can be defined per source target using the `pch` property. One can include as many headers as they wish to inside of the precompiled header itself.

```json
"my-target": {
   "files": "src/**.cpp",
   "settings:Cxx": {
      "pch": "src/PCH.hpp"
   }
}
```

This will automatically include that header in every source file of that target. Although there's nothing stopping one from doing so, it's not necessary to include it again at the top of source files via `#include`. Every compiler handles precompiled headers a little differently under the hood, so Chalet abstracts that away for you.

> Note: In `universal` architecture builds on MacOS, a separate precompiled header is created for each architecture.

\\

## [Dynamic Linking]

Linking shared libraries is quite simple in Chalet. Like with the `-l` option in GCC/Clang, only the base name of the library needs to be supplied. Thus, `libfoo.a` would be linked as `foo`. If you are using MSVC, and the library is `foo.lib`, the link is again just `foo`.

```json
"links": [
   "foo"
],
"links.debug": [
   "bar-d"
],
"links.!debug": [
   "bar"
],
"links.windows": [
   "user32"
]
```

If linking to another target, the target must build prior to the current target, and one only needs to supply the target name to `links`.

```json
"first-target": {
   "kind": "sharedLibrary",
   "files": "src/foo/**.cpp",
},
"second-target": {
   "settings:Cxx": {
      "links": [
         "first-target"
      ]
   }
}
```

You might run into a situation where a library is only supported on a certain platform, or is only relevant in a Debug build. Expressing that is quite easy:

```json
"first-target": {
   "kind": "sharedLibrary",
   "condition": "windows",
   "files": "src/foo/**.cpp"
},
"second-target": {
   "settings:Cxx": {
      "links.windows": [
         "first-target"
      ]
   }
```

See also: [Advanced: Fine Tuning](/creating-targets?id=advanced-fine-tuning)


\\

## [Static Linking]

Static links work the same way as shared, but use the `staticLinks` property instead. However, static library targets will have an output filename with a "-s" suffix behind the scenes. If linking to a prebuilt static library, or one built with CMake for instance, the suffix will need to be added, if applicable.

```json
"first-target": {
   "kind": "staticLibrary",
   "files": "src/foo/**.cpp"
},
"second-target": {
   "settings:Cxx": {
      "staticLinks": [
         "first-target"
      ]
   }
}
```

The actual file being linked in that example is `libfirst-target-s.a`, but we only care about the target name here.

See also: [Advanced: Fine Tuning](/creating-targets?id=advanced-fine-tuning)

\

<!-- accordion:start Static Linking Compiler Libraries (libstdc++ etc) -->

There's an extra property for this: `staticLinking`, but has different behavior on each toolchain. For those familar with GCC, it does not use `-static` (which links every link following it statically, including compiler libraries) but instead uses the explicit versions:

```
-static-libgcc
-static-libasan
-static-libtsan
-static-liblsan
-static-libubsan
-static-libstdc++
```

This is particularly useful with MinGW, as it means not having to distribute as many .dll files, whereas on linux it may be less desireable.

In LLVM, `staticLinking` just passes `-static-libsan` at the moment, and in MSVC, does nothing.

<!-- accordion:end -->

\\

## [C++ Modules]

To enable modules (requires C++20 - currently only works with MSVC), set `cppModules` to true. This will treat **all** source files in that target location as modules. 

```json
"modules-target": {
   "settings:Cxx": {
      "cppModules": true
   }
}
```

If mixing with non-module C++ code, one must create a static library target without `cppModules`, import those headers in your module code, and statically link the non-modules target.

```json
"non-modules-target": {
   "kind": "staticLibrary",
   "settings:Cxx": {
      "includeDirs": [
         "include/foo"
      ]
   },
   "files": "src/foo/**.cpp"
},
"modules-target": {
   "settings:Cxx": {
      "cppModules": true,
      "includeDirs": [
         "include/foo"
      ],
      "staticLinks": [
         "non-modules-target"
      ]
   },
   "files": "src/bar/**.cpp"
}
```

Modules have a complicated build process compared to other C++ code, so they are built natively through Chalet, instead of using Ninja/Make. Fortunately, this is very fast, and comparable to doing so in msbuild/inside Visual Studio. Other build targets still use Ninja/Make. Because module source code file extensions can technically be anything in the same way as regular C++ code, it makes the most sense to separate out the two types of source code in the build.

\\

## [Run Targets]

If a target is runnable (kind is `executable` or `script`), one only needs to set `runTarget` to `true` in order to choose it as the target that gets run during `chalet buildrun` and `chalet run`. If more than one target has the `runTarget` property, or none have it, then the first runnable target is chosen.

```json
"first-target": {
   "kind": "executable",
   "files": "src/**.cpp"
},
"second-target": {
   "kind": "script",
   "file": "scripts/do_something.sh",
   "runTarget": true
}
```

An executable target can also take the `runArguments` and `runDependencies` properties. The `runArguments` property is simply an array of arguments to pass to the executable, while `runDependencies` is meant for shared libraries that have to be copied to the build folder at the time of execution. In most cases, it's not needed as long as the shared library is accessible from PATH, but if LoadLibrary is called in Windows api for example, it might be necessary to have the file in the same path as the executable.

```json
"first-target": {
   "kind": "executable",
   "files": "src/**.cpp",
   "runTarget": true,
   "runArguments": [
      "--foo",
      "-i",
      "bar"
   ],
   "runDependencies.windows": [
      "${env:SOME_PATH}/stubborn_lib.dll"
   ]
}
```

> Note: If a run target is specified from the command line, it will take precedence over any targets with the `runTarget` property.

\\

## [Path Substitution]

In properties that take paths to directories or files, path substitution is supported for certain variables that describe locations of the build that could vary between machines. The following is supported:

* `~/`, `${home}` - resolves to the home directory of the machine. On Windows, this is `C:\Users\(Name)`
* `${env:(Name)}` - resolves an environment variable by name. For example: `${env:MY_LIBRARY_PATH}`
* `${buildDir}` - resolves to the main build directory for the current configuration & architecture
* `${externalDir}` - resolves to the root path for external dependencies. See [externalDependencies](/schema-dev/latest?id=external-dependencies)
* `${externalBuildDir}` - resolves to the build path for an external dependency. For instance, if a CMake project is located at `${externalDir}/foo`, it will build to `${buildDir}/${externalDir}/foo`, so it's easier to write `${externalBuildDir}/foo`
* `${cwd}` - resolves the current working directory (this shouldn't be needed, but it's here just in case)

Example:

```json
"searchPaths": [
   "${externalBuildDir}/foo/arbitrary-path"
],
"targets": {
   "my-target": {
      "settings:Cxx": {
         "includeDirs": [
            "${env:MY_BAR_LIB}/include"
         ],
         "includeDirs.windows": [
            "${env:ProgramFiles}/bar/include"
         ],
         "includeDirs.!windows": [
            "~/libs/bar/include"
         ]
      },
      "files": "${externalDir}/foo/**.cpp",
   },
   "other-target": {
      "settings:Cxx": {
         "includeDirs": [
            "${externalDir}/foo/include"
         ],
         "libDirs": [
            "${externalBuildDir}/foo"
         ],
         "links": [
            "foo"
         ]
      }
   }
}
```

\\

## [Advanced: Fine Tuning]

**Per-toolchain properties**

As a last resort, `compileOptions` and `linkerOptions` can pass certain options directly to the build at the time of a compilation unit's compile, or at link time. As Chalet evolves, more options will be leveraged as properties, and the goal will be to reduce the need for this as much as possible. Both of these properties take a single string of options. 

These properties, in addition to `warnings`, `defines`, `links`, `staticLinks`, `includeDirs` and `libDirs` can also be defined _per compiler toolchain_. This is done by defining them as an object, followed by either the architecture triple or a toolchain name. Like with abstracts, the `*` property is applied to all. If both a matching target triple and a toolchain name are defined, the triple's is read first, followed by the toolchain name's values. Partial triple names can also be used, but the more specific, the better.

If you require an even more refined build, you can certainly combine CMake with Chalet.

> Note: This feature is still experimental and things may not work as expected

```json
"compileOptions": {
   "arm-linux-gnueabihf": "...",
   "arm64-apple-darwin": "...",
   "x86_64-pc-windows-msvc": "...",
   "w64-mingw32": "..."
}
```

`w64-mingw32` could refer to either `x86_64-w64-mingw32` or `i686-w64-mingw32`.

```json
"libDirs": {
   "*": [
      "${externalDir}/foo/lib",
      "${externalDir}/bar/lib"
   ],
   "arm64-apple-darwin": [
      "${externalDir}/vendor/macos/lib"
   ],
   "arm64-apple-darwin.debug": [
      "${externalDir}/vendor/macos-debug/lib"
   ],
   "x86_64-pc-windows-msvc": [
      "${externalDir}/vendor/msvc/lib"
   ]
}
```

> Note: `warnings` in this case is for defining specific warnings, not presets. 

\

**Linker Scripts**

At the moment, this is just supported with GCC & Clang, but you can supply a linker script to the the linker via the `linkerScript` property.

\\

## [Chalet Targets]

Chalet targets are like saying "I have a Chalet project in a separate repository and want it to build during this project's build."  This is a feature that may not get a lot of use in these early days, but could serve as a foundation for package management in the future. One would want to combine this feature with `externalDependencies`, which would pull down a git repository prior to building.

To build another Chalet project, set `kind` to `chaletProject`, and define the `location` as the directory where the `chalet.json` of the project exists. If using a custom build file name, you can specify it with `buildFile`. This is a path relative to the location, so by default its value is `chalet.json`.

The only other property is `recheck` which if true, will check the project for changes each time a build is run. If not defined, this will default to `true`. Setting this to false by nature would speed up rebuilds because chalet wouldn't need to be invoked after the target has already been built once.

```json
"my-chalet-target": {
   "kind": "chaletProject",
   "condition": "!windows",
   "location": "${externalDir}/bar",
   "recheck": false
}
```

\\

## [CMake Targets]

CMake projects can be built as a build step / target of a Chalet project. This is the ideal choice for working with a library needs to be built with CMake before a source target that relies on that library, or if a build is better accomplished with CMake, but one wants to use Chalet to manage the command given to CMake. Chalet will pick an appropriate CMake generator based on its own toolchain, generate the build files with the given defines and toolset specification (if applicable), then build during the same step (using the `cmake --build` method). 

At the moment, these are the generators used:

* **Ninja** - If the toolchain's `strategy` is ninja, this will always be the generator.
* **Visual Studio ## ####** - If using MSVC and not using Ninja, this generator will be based on the version of MSVC detected (up to Visual Studio 17 2022).
* **MinGW Makefiles** - If on Windows, and the toolchain does not use Ninja or MSVC.
* **Unix Makefiles** - If not Windows, and the toolchain does not use Ninja.

To build another CMake project, set `kind` to `cmakeProject`, and define the `location` as the directory where the `CMakeLists.txt` of the project exists. If using a custom build file name, you can specify it with `buildFile`. This is passed directly to the `-C` CMake option.

The only other property is `recheck` which if true, will check the project for changes each time a build is run. If not defined, this will default to `true`. Setting this to false by nature would speed up rebuilds because CMake wouldn't need to be invoked after the target has already been built once.

```json
"my-cmake-target": {
   "kind": "cmakeProject",
   "condition": "!windows",
   "location": "${externalDir}/foo",
   "recheck": false
}
```

If using a toolset specification (`-T` option), simply define it under `toolset`.

Chalet will attempt to add appropriate cache entries with `-D` based on its own settings and toolchain, but if one wants to override these, this can be done by adding `defines` manually, without the `-D` option.

```json
"my-cmake-target": {
   "kind": "cmakeProject",
   "location": "${externalDir}/foo",
   "defines": [
      "CMAKE_C_COMPILER=foo",
      "CMAKE_CXX_COMPILER=foo++"
   ]
}
```

\\

## [Script Targets]

Script targets are quite simple. They are triggered by setting the `kind` property to `script`. In addition to the `condition` and `description` properties, they only take a `script` property (that can also be suffixed with a property condition.

The following file extensions are supported:
* `.sh` - Bash / Unix shell
* `.bat` - Windows Batch
* `.ps1` - Powershell ([Powershell Core](https://github.com/PowerShell/PowerShell) is also supported on non-windows)
* `.py` - Python
* `.rb` - Ruby
* `.pl` - Perl
* `.lua` - Lua

Portable shebangs — `#!/usr/bin/env (executable)` — are supported with any extension.

The following examples are all valid:

```json
"my-first-script": {
   "kind": "script",
   "description": "The very first script",
   "file.!windows": "scripts/script.sh",
   "file.windows": "scripts/script.bat",
}
"my-second-script": {
   "kind": "script",
   "condition": "windows",
   "file.debug": "scripts/script_Debug.bat",
   "file.!debug": "scripts/script_Release.bat"
}
"my-second-script": {
   "kind": "script",
   "condition": "windows",
   "file": "scripts/script.ps1"
}
"my-third-script": {
   "kind": "script",
   "file": "scripts/script.py"
}
```

\\

## [Process Targets]

TODO

<!-- nav:/managing-dependencies:/describing-the-distribution -->
